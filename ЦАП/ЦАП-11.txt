from collections import defaultdict
import unittest


class StateMachineException(Exception):
    pass


class MooreMachine:
    def __init__(self):
        self.transitions = {
            't3': {
                'hike': [{'next_state': 't2', 'cond': None, 'output': 'S0'}],
                'visit': [{'next_state': 't7', 'cond': None, 'output': 'S1'}]
            },
            't2': {
                'spin': [{'next_state': 't1', 'cond': None, 'output': 'S2'}]
            },
            't1': {
                'hike': [{'next_state': 't6', 'cond': None, 'output': 'S2'}]
            },
            't6': {
                'hike': [{'next_state': 't7', 'cond': None, 'output': 'S2'}],
                'swap': [{'next_state': 't7', 'cond': None, 'output': 'S2'}]
            },
            't7': {
                'cast': [
                    {'next_state': 't1', 'cond': {'var': 'c', 'value': 1}, 'output': 'S2'},
                    {'next_state': 't0', 'cond': {'var': 'c', 'value': 0}, 'output': 'S1'}
                ],
                'swap': [{'next_state': 't6', 'cond': None, 'output': 'S2'}]
            },
            't0': {
                'spin': [
                    {'next_state': 't6', 'cond': {'var': 'x', 'value': 0}, 'output': 'S0'},
                    {'next_state': 't4', 'cond': {'var': 'x', 'value': 1}, 'output': 'S2'}
                ]
            },
            't4': {
                'visit': [{'next_state': 't5', 'cond': None, 'output': 'S1'}]
            },
            't5': {
                'hike': [{'next_state': 't6', 'cond': None, 'output': 'S0'}]
            }
        }
        self.current_state = 't3'
        self.variables = {'c': None, 'x': None}
        self.methods_seen = defaultdict(int)
        self._build_edge_counts()
        self._build_reachability()

    def _build_edge_counts(self):
        self.out_edges_count = defaultdict(int)
        for from_state, methods in self.transitions.items():
            for method, transitions in methods.items():
                self.out_edges_count[from_state] += len(transitions)

    def _build_reachability(self):
        self.reachability = defaultdict(set)
        nodes = set(self.transitions.keys())
        for node in nodes:
            visited = set()
            stack = [node]
            while stack:
                current = stack.pop()
                if current not in visited:
                    visited.add(current)
                    if current in self.transitions:
                        for method, transitions in self.transitions[current].items():
                            for trans in transitions:
                                if trans['next_state'] not in visited:
                                    stack.append(trans['next_state'])
            self.reachability[node] = visited

    def has_max_out_edges(self):
        if not self.out_edges_count:
            return False
        current_out = self.out_edges_count.get(self.current_state, 0)
        max_out = max(self.out_edges_count.values())
        return current_out == max_out

    def let_c(self, value):
        self.variables['c'] = value

    def let_x(self, value):
        self.variables['x'] = value

    def link(self):
        raise StateMachineException('unknown')

    def seen_method(self, method_name):
        return self.methods_seen.get(method_name, 0) > 0

    def has_path_to(self, state):
        if state not in self.reachability:
            return False
        return state in self.reachability.get(self.current_state, set())

    def visit(self):
        return self._execute_method('visit')

    def cast(self):
        return self._execute_method('cast')

    def spin(self):
        return self._execute_method('spin')

    def hike(self):
        return self._execute_method('hike')

    def close(self):
        raise StateMachineException('unknown')

    def _execute_method(self, method_name):
        if method_name not in self.transitions.get(self.current_state, {}):
            raise StateMachineException('unsupported')

        transitions = self.transitions[self.current_state][method_name]

        for trans in transitions:
            cond = trans.get('cond')
            if cond is None or self.variables.get(cond['var']) == cond['value']:
                self.current_state = trans['next_state']
                self.methods_seen[method_name] += 1
                return trans['output']

        raise StateMachineException('unsupported')


class TestMooreMachine(unittest.TestCase):
    def setUp(self):
        self.machine = MooreMachine()

    def test_has_max_out_edges_empty(self):
        machine = MooreMachine()
        machine.out_edges_count = {}
        self.assertFalse(machine.has_max_out_edges())

    def test_has_max_out_edges_normal(self):
        self.machine.current_state = 't7'
        self.assertTrue(self.machine.has_max_out_edges())

        self.machine.current_state = 't3'
        self.assertFalse(self.machine.has_max_out_edges())

    def test_execute_method_condition_branch(self):
        self.machine.current_state = 't7'
        self.machine.let_c(1)
        self.assertEqual(self.machine.cast(), 'S2')

        self.machine.current_state = 't7'
        self.machine.let_c(0)
        self.assertEqual(self.machine.cast(), 'S1')

    def test_execute_method_no_condition_branch(self):
        self.assertEqual(self.machine.visit(), 'S1')

    def test_execute_method_unsupported(self):
        self.machine.current_state = 't1'
        with self.assertRaises(StateMachineException) as context:
            self.machine.visit()
        self.assertEqual(str(context.exception), 'unsupported')

    def test_build_reachability(self):
        self.assertTrue(self.machine.has_path_to('t7'))
        self.assertTrue(self.machine.has_path_to('t0'))
        self.assertTrue(self.machine.has_path_to('t4'))
        self.assertTrue(self.machine.has_path_to('t5'))
        self.assertTrue(self.machine.has_path_to('t6'))
        self.assertFalse(self.machine.has_path_to('nonexistent'))

    def test_reachability_empty_transitions(self):
        machine = MooreMachine()
        machine.current_state = 'non_existent_state'
        self.assertFalse(machine.has_path_to('t1'))
        self.assertIsInstance(machine.reachability, defaultdict)
        self.assertIn('t3', machine.reachability)
        self.assertNotIn('non_existent_state', machine.reachability)

    def test_all_methods_coverage(self):
        self.assertFalse(self.machine.seen_method('visit'))
        self.machine.visit()
        self.assertTrue(self.machine.seen_method('visit'))

        self.machine.let_c(1)
        self.machine.let_x(0)

        with self.assertRaises(StateMachineException):
            self.machine.link()

        with self.assertRaises(StateMachineException):
            self.machine.close()

    def test_edge_cases(self):
        machine = MooreMachine()
        machine.transitions = {}
        machine._build_edge_counts()
        machine._build_reachability()
        self.assertFalse(machine.has_max_out_edges())
        self.assertFalse(machine.has_path_to('any_state'))


if __name__ == "__main__":
    unittest.main()